package main

//互斥锁，是传统并发编程中对共享资源精选访问控制的主要手段，go中，sync标准库提供了Mutex结构体类型标识，提供了两个方法，Lock和Unlock，Lock锁定当前的共享资源，Unlock进行解锁

//读写锁，上面的互斥锁本质是当一个goroutine访问的时候，其他goroutine都不能访问，这样虽然资源同步，避免竞争的同时也降低了程序的并发性能，程序由原来的并行执行变成了串行执行
//而当我们对一个不会变化的数据只做读操作的话，不存在资源竞争问题，因为数据是不变的，多少个协程同时读取，怎么读取，都是可以的
//所以问题不是出现在读上，主要是修改，也就是写，修改的数据要同步，这样其他协程才可以感知到，所以真正的互出应该是读取和修改，修改和修改之间，读取和读取之间没有互斥操作的必要
//读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的，也就是说，当一个协程进行写操作的时候，其他协程既不能进行读操作，也不能进行写操作。
//go中，读写锁由结构体类型sync.RWMutex表示，包含两对方法，
//Lock，Unlock:对写操作的锁定和解锁，简称写锁定和写解锁 完全互斥
//RLock、RULock”另一组表示对读操作的锁定和解锁，简称都锁定和读解锁
